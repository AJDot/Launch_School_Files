type: "MARKDOWN_NOTE"
folder: "ff77bd190bcb406a1e6c"
title: "Study Guide for Test"
content: '''
  # Study Guide for Test
  
  ## Blocks
  
  ### Closures and scope
  Closures give the ability to save a section of code and execute it at a later time. It binds its surround artifacts (variables, methods, objects, etc) and "encloses" it so that everything can be referenced when the closure is executed later.
  
  A __closure__ is a block of code that can be run at a later time.
  * an "enclosure" is built around it to surround its artifacts.
  * kind of like a method without a name.
  
  In Ruby, a closure is implemented through a `proc` object.
  
  __Remember:__ the `Proc` object retains references to its surrounding artifacts - its binding. This is how understands its surroundings and carries the information to it place of execution.
  
  Three ways to work with closures in Ruby
  1. Instantiating an object from the `Proc` class
  2. Using __lambdas__
  3. Using __blocks__
  
  When one of these ways is used, the artifacts that are surrounded will be accessible in places they normally would be. Example:
  
  ### How blocks work, and when we want to use them.
  Blocks are written using `do...end` or `{...}`. Blocks are actually _passed into_ a method called on an object. Here are a few examples of using blocks.
  ```ruby
  [1, 2, 3].each do |num|
    puts num
  end
  => [1, 2, 3]
  
  5.times do { |num| puts num }
  => 5
  
  File.open('some_file.txt', 'w') do |file|
    file.write('this is being written to the file!')
  end
  => 34 # number of characters in string
  ```
  The code inside each block will run as expected and each block has a return value. Exactly how a block will be treated is defined in the method that block is being passed into. The return value, however, works just the same as for methods; it is the last line of the block unless explicitly specified using the `return` reserved word.
  
  #### When would we want to use blocks?
  1. Defer some implementation code to method invocation time. 
    Sometimes a method may need a little tweaking when called but that tweak could be something a little different every time it is called. This is a prime case for the use of a block. 
    Let's look at an example case without blocks first - an attempt to predict these tweaks.
      ```ruby
      def compare(num, compare_value, compare_type)
        result = case compare_type
        when :>
        num > compare_value
        when :<
        num < compare_value
        when :==
        num == compare_value
        end
        result ? "This is true!" : "This is false!"
      end
      ```
      For one, this doesn't read well. For two, what if the users wants to compare value in a different way? And in a more readable way? Use a block!
      ```ruby
      def compare(num)
        yield(num) ? "This is true!" : "This is false!"
      end
      ```
      This is a trivial example but you get the point. Now I can compare `num` in any way I like. If the block returns a truthy value, then the comparison is true. This lets the user decide _how_ the comparison is to be made but also doesn't need to worry about implementing it.
      If you find you need a method in multiple places __with only a tweak to each call__, then a block maybe be a good idea.
      
  
  2. Methods that need some "before" and "after" actions - sandwich code.
    If you need to run some code before and after _anything_ then a block is probably for you. One easy example is timing code execution. Example
      ```ruby
      def time_it
        time_before = Time.now
        yield
        time_after = Time.now
        
        puts "it took #{time_after - time_before} seconds."
      end
      
      time_it { sleep(3) }
      
      time_it { "hello world" }
      ```
      Common uses of sandwich code:
      1. timing
      2. logging
      3. notification systems
      4. opening/closing files
    
  ### Blocks and variable scope
  #### Closure and binding
  Where the `chunk_of_code` is instantiated is what the chunk will keep track of. If a `Proc` object is defined outside of a method, it can be called inside that method when passed into it, even if the `Proc` contains information the method itself does not explicitly see. Example:
  ```ruby
  def call_me(some_code)
    some_code.call
  end
  
  name = "Robert"
  chunk_of_code = Proc.new {puts "hi #{name}"}
  
  call_me(chunk_of_code)
  ```
  The output is:
  ```bash
  hi Robert
  => nil
  ```
  It actually works even though the local variable `name` was not passed into the `call_me` method. Local variables shouldn't be able to be accessed inside a method unless they are passed in as arguments. 
  
  The `Proc` keeps track of its surrounding context and drags it around with it. Even if the surrounding context changes after the `Proc` was defined, it will be kept up-to-date. Example:
  ```ruby
  def call_me(some_code)
    some_code.call
  end
  
  name = "Robert"
  chunk_of_code = Proc.new {puts "hi #{name}"}
  name = "Bill"
  
  call_me(chunk_of_code)
  ```
  And the output is...
  ```bash
  hi Bill
  => nil
  ```
  This not only includes local variables, but method references, constants, and others. This is the core reason behind scoping rules in Ruby. This is why "inner scopes can access outer scopes".
  ### Write methods that use blocks and procs
  ### Arguments and return values with blocks
  ### When can you pass a block to a method
  ### &:symbol
  
  ## Testing With Minitest
  
  ### Testing terminology
  ### Minispec vs. RSpec
  ### SEAT approach
  ### Assertions
  
  ## Core Tools/Packaging Code
  
  ### Purpose of core tools
  ### Gemfiles
  
  ## Regular Expressions
'''
tags: []
isStarred: false
createdAt: "2017-05-31T12:15:32.412Z"
updatedAt: "2017-05-31T14:16:20.059Z"
